#include <iostream>
#include <cassert>
using namespace  std;

// This transition table is generated by GenerateScanDFA
int Transitions[16][3] =
{
	{0,     0,      0}
	{8,     4,      2}
	{8,     2,      2}
	{8,     6,      2}
	{4,     1,      4}
	{12,    5,      6}
	{12,    3,      6}
	{12,    7,      6}
	{8,     4,      2}
	{8,     4,      2}
	{8,     6,      2}
	{8,     6,      2}
	{12,    5,      6}
	{12,    5,      6}
	{12,    7,      6}
	{12,    7,      6}
};

struct State
{
	int state;
	// this value indicates when the last separator is quoted whether it's possbile that
	// the entire processed string including the last separator is in one filed
	// This is very useful when the return state is not 0 or 5.
	bool sameField;
};

// scan unti reaching a valid seperator
State ScanCSV(const char* ipCSV, const char* ipEnd = NULL)
{
	State s = {15, true};

	const char* lpEnd = (ipEnd == NULL ? ipCSV + strlen(ipCSV): ipEnd);

	for(const char* lpCurrent = ipCSV; lpCurrent < lpEnd; lpCurrent++)
	{
		switch(s.state)
		{
		case 0:
		case 5:
			return s;
			break;
		case 1:
		case 3:
			s.sameField = false;
			break;
		default:
			break;
		}

		switch(*lpCurrent)
		{
		case ',':
			s.state = Transitions[s.state][0];
			break;
		case '|':
			s.state = Transitions[s.state][1];
			break;
		default:
			s.state = Transitions[s.state][2];
			break;
		}
	}
	return s;
}


int main()
{
	// use | as quote char
	// CSV char should end with char ,
	// check whether the last separatr is valid

	bool lSameField = true;

	{
		// CSV strictly follow RFC4180, no partially quoted filed

		// valid separtors
		assert(BackScanCSV("A|A,").state == 5);
		assert(BackScanCSV("A|||A,").state == 5);
		assert(BackScanCSV("A|||||A,").state == 5);
		assert(BackScanCSV("A|||||||A,").state == 5);
		assert(BackScanCSV("A|||||||||A,").state == 5);
		assert(BackScanCSV("A|||||||||,").state == 5);
		assert(BackScanCSV("A|||||||,").state == 5);
		assert(BackScanCSV("A|||||,").state == 5);
		assert(BackScanCSV("A|||,").state == 5);
		assert(BackScanCSV("A|,").state == 5);

		// valid separtors
		assert(BackScanCSV("A|,|,A,|,").state == 5);
		assert(BackScanCSV("A|,|,A,|,A,|,A,|,").state == 5);

		// quoted separators
		assert(BackScanCSV("A|A,|,").state == 0);
		assert(BackScanCSV("A|||A,|,").state == 0);
		assert(BackScanCSV("A|||||A,|,").state == 0);
		assert(BackScanCSV("A|||||||A,|,").state == 0);
		assert(BackScanCSV("A|||||||||A,|,").state == 0);
		assert(BackScanCSV("A|||||||||,|,").state == 0);
		assert(BackScanCSV("A|||||||,|,").state == 0);
		assert(BackScanCSV("A|||||,|,").state == 0);
		assert(BackScanCSV("A|||,|,").state == 0);
		assert(BackScanCSV("A|,|,").state == 0);

		// quoted separators
		assert(BackScanCSV("A|A,|,A,|,A,|,").state == 0);
	}

	{
		// CSVs don't strictly follow RFC4180,  have partially quoted fileds

		// valid separtors
		assert(BackScanCSV("A|A,|A|A,").state == 5);
		assert(BackScanCSV("A|||A,|A|A,").state == 5);
		assert(BackScanCSV("A|||||A,|A|A,").state == 5);
		assert(BackScanCSV("A|||||||A,|A|A,").state == 5);
		assert(BackScanCSV("A|||||||||A,|A|A,").state == 5);
		assert(BackScanCSV("A|||||||||,|A|A,").state == 5);
		assert(BackScanCSV("A|||||||,|A|A,").state == 5);
		assert(BackScanCSV("A|||||,|A|A,").state == 5);
		assert(BackScanCSV("A|||,|A|A,").state == 5);
		assert(BackScanCSV("A|,|A|A,").state == 5);

		// valid separtors
		assert(BackScanCSV("A|,|A|A,|,A,|,").state == 5);
		assert(BackScanCSV("A|,|,A,|,|A|A,A,|,A,|,").state == 5);

		// quoted separators
		assert(BackScanCSV("A|A,|A|A,|,").state == 0);
		assert(BackScanCSV("A|||A,|A|A,|,").state == 0);
		assert(BackScanCSV("A|||||A,|A|A,|,").state == 0);
		assert(BackScanCSV("A|||||||A,|A|A,|,").state == 0);
		assert(BackScanCSV("A|||||||||A,|A|A,|,").state == 0);
		assert(BackScanCSV("A|||||||||,|A|A,|,").state == 0);
		assert(BackScanCSV("A|||||||,|A|A,|,").state == 0);
		assert(BackScanCSV("A|||||,|A|A,|,").state == 0);
		assert(BackScanCSV("A|||,|A|A,|,").state == 0);
		assert(BackScanCSV("A|,|A|A,|,").state == 0);

		// quoted separators
		assert(BackScanCSV("A|A,|,A,|,|A|A,A,|,").state == 0);
	}

	{
		// sperators whose status cannot be determined

		// if the last separator is qutoed, then the entire stirng is in one field
		assert(BackScanCSV("A,A,A,").state == 4 && BackScanCSV("A,A,A,").sameField);
		assert(BackScanCSV("A,||A,A,").state == 4 && BackScanCSV("A,||A,A,").sameField);
		assert(BackScanCSV("A,||||A,A,").state == 4 && BackScanCSV("A,||||A,A,").sameField);

		// cannot determine whether the entire stirng is in on field
		assert(BackScanCSV("A,|||A,A,").state == 1 && !BackScanCSV("A,|||A,A,").sameField);
		assert(BackScanCSV("A,|,").state == 1 && !BackScanCSV("A,|,").sameField);
		assert(BackScanCSV("A,|,A,|,").state == 4 && !BackScanCSV("A,|,A,|,").sameField);
		assert(BackScanCSV("A,|,A,|,A,|,").state == 1 && !BackScanCSV("A,|,A,|,A,|,").sameField);
		assert(BackScanCSV("A,|,A,|,A,|,A,|,").state == 4 && !BackScanCSV("A,|,A,|,A,|,A,|,").sameField);
	}

	return 0;
}