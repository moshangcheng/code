/**
 * @author moshangcheng
 * @version 1.0
 * @date 2011-7-22 下午06:59:29
 * @brief TopCoder SRM509 C
 * 判重必须使用nodeHash[c][r][k]，不能使用nodeHash[c][r]，考虑
 * 1.01.
 * 11110
 * 0000e
 * (0,0)为初始点,(2,4)为终点,K=1的情况
 */
#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>

using namespace std;
class Node {
public:
	int r, c;
	int k;
	int d;
	Node(int r, int c, int k, int d) :
		r(r), c(c), k(k), d(d) {
	}
};

class NodeCompare {
public:
	inline bool operator ()(const Node& a, const Node& b) {
		if (a.d > b.d) {
			return true;
		} else if (a.d == b.d && a.k < b.k) {
			return true;
		} else {
			return false;
		}
	}
};

const int MAX = 51;
vector<Node> nodeHeap;
bool nodeHash[MAX][MAX][MAX];

class NumberLabyrinthDiv2 {
public:
	int R, C;
	vector<string> board;

	char inline getValue(int r, int c) {
		return board[r][c];
	}

	void pushNode(int v, const Node& cnt, int deltaK) {
		if (cnt.r + v < R) {
			Node node = Node(cnt.r + v, cnt.c, cnt.k - deltaK, cnt.d + 1);
			if (!nodeHash[node.r][node.c][node.k]) {
				nodeHeap.push_back(node);
				push_heap(nodeHeap.begin(), nodeHeap.end(), NodeCompare());
			}
		}
		if (cnt.c + v < C) {
			Node node = Node(cnt.r, cnt.c + v, cnt.k - deltaK, cnt.d + 1);
			if (!nodeHash[node.r][node.c][node.k]) {
				nodeHeap.push_back(node);
				push_heap(nodeHeap.begin(), nodeHeap.end(), NodeCompare());
			}
		}
		if (cnt.r >= v) {
			Node node = Node(cnt.r - v, cnt.c, cnt.k - deltaK, cnt.d + 1);
			if (!nodeHash[node.r][node.c][node.k]) {
				nodeHeap.push_back(node);
				push_heap(nodeHeap.begin(), nodeHeap.end(), NodeCompare());
			}
		}
		if (cnt.c >= v) {
			Node node = Node(cnt.r, cnt.c - v, cnt.k - deltaK, cnt.d + 1);
			if (!nodeHash[node.r][node.c][node.k]) {
				nodeHeap.push_back(node);
				push_heap(nodeHeap.begin(), nodeHeap.end(), NodeCompare());
			}
		}
	}

	int getMinimumNumberOfMoves(vector<string> board, int r1, int c1, int r2,
			int c2, int K) {
		//init
		this->board = board;
		this->R = board.size();
		this->C = board[0].size();
		nodeHeap.clear();
		fill(nodeHash[0][0], nodeHash[MAX][0], 0);
		nodeHeap.push_back(Node(r1, c1, K, 0));
		make_heap(nodeHeap.begin(), nodeHeap.end(), NodeCompare());
		while (!nodeHeap.empty()) {
			Node cnt = nodeHeap.front();
			pop_heap(nodeHeap.begin(), nodeHeap.end(), NodeCompare());
			nodeHeap.pop_back();
			if (nodeHash[cnt.r][cnt.c][cnt.k]) {
				continue;
			}
			nodeHash[cnt.r][cnt.c][cnt.k] = true;
			if (cnt.c == c2 && cnt.r == r2) {
				return cnt.d;
			}
			char v = getValue(cnt.r, cnt.c);
			switch (v) {
			case ('.'):
				if (cnt.k > 0) {
					for (int i = 1; i < 10; i++) {
						pushNode(i, cnt, 1);
					}
				}
				break;
			case ('0'):
				break;
			default:
				pushNode(v - '0', cnt, 0);
				break;
			}
		}
		return -1;
	}
};

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.4 (beta) modified by pivanof
bool KawigiEdit_RunTest(int testNum, vector<string> p0, int p1, int p2, int p3,
		int p4, int p5, bool hasAnswer, int p6) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}" << "," << p1 << "," << p2 << "," << p3 << "," << p4 << ","
			<< p5;
	cout << "]" << endl;
	NumberLabyrinthDiv2 *obj;
	int answer;
	obj = new NumberLabyrinthDiv2();
	clock_t startTime = clock();
	answer = obj->getMinimumNumberOfMoves(p0, p1, p2, p3, p4, p5);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC
			<< " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p6 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p6;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;

	vector<string> p0;
	int p1;
	int p2;
	int p3;
	int p4;
	int p5;
	int p6;

	{
		// ----- test 0 -----
		string t0[] = { "...2", "....", "3..." };
		p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
		p1 = 0;
		p2 = 0;
		p3 = 2;
		p4 = 3;
		p5 = 0;
		p6 = -1;
		all_right = KawigiEdit_RunTest(0, p0, p1, p2, p3, p4, p5, true, p6)
				&& all_right;
		// ------------------
	}

	{
		// ----- test 1 -----
		string t0[] = { "...2", "....", "3..." };
		p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
		p1 = 0;
		p2 = 0;
		p3 = 2;
		p4 = 3;
		p5 = 1;
		p6 = 2;
		all_right = KawigiEdit_RunTest(1, p0, p1, p2, p3, p4, p5, true, p6)
				&& all_right;
		// ------------------
	}

	{
		// ----- test 2 -----
		string t0[] = { "...3", "....", "2..." };
		p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
		p1 = 0;
		p2 = 0;
		p3 = 2;
		p4 = 3;
		p5 = 3;
		p6 = 3;
		all_right = KawigiEdit_RunTest(2, p0, p1, p2, p3, p4, p5, true, p6)
				&& all_right;
		// ------------------
	}

	{
		// ----- test 3 -----
		string t0[] = { "55255", ".0.0.", "..9..", "..3..", "3.9.3", "44.44" };
		p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
		p1 = 3;
		p2 = 2;
		p3 = 4;
		p4 = 2;
		p5 = 10;
		p6 = 6;
		all_right = KawigiEdit_RunTest(3, p0, p1, p2, p3, p4, p5, true, p6)
				&& all_right;
		// ------------------
	}

	{
		// ----- test 4 -----
		string
				t0[] = { "920909949", "900020000", "009019039", "190299149",
						"999990319", "940229120", "000409399", "999119320",
						"009939999" };
		p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
		p1 = 7;
		p2 = 3;
		p3 = 1;
		p4 = 1;
		p5 = 50;
		p6 = 10;
		all_right = KawigiEdit_RunTest(4, p0, p1, p2, p3, p4, p5, true, p6)
				&& all_right;
		// ------------------
	}

	{
		// ----- test 5 -----
		string t0[] = { "..................................................",
				"..................................................",
				"..................................................",
				"..................................................",
				"..................................................",
				"..................................................",
				"..................................................",
				"..................................................",
				"..................................................",
				"..................................................",
				"..................................................",
				"..................................................",
				"..................................................",
				"..................................................",
				"..................................................",
				"..................................................",
				"..................................................",
				"..................................................",
				".............................................."
					"....",
				"..................................................",
				"..................................................",
				"..................................................",
				"..................................................",
				"..................................................",
				"..................................................",
				"..................................................",
				"..................................................",
				"..................................................",
				"..................................................",
				"..................................................",
				"..................................................",
				"..................................................",
				"..................................................",
				"..................................................",
				"..................................................",
				"..................................................",
				"..................................................",
				"........................................"
					"..........",
				"..................................................",
				"..................................................",
				"..................................................",
				"..................................................",
				"..................................................",
				"..................................................",
				"..................................................",
				"..................................................",
				"..................................................",
				"..................................................",
				"..................................................",
				".................................................." };
		p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
		p1 = 0;
		p2 = 0;
		p3 = 49;
		p4 = 49;
		p5 = 50;
		p6 = 12;
		all_right = KawigiEdit_RunTest(5, p0, p1, p2, p3, p4, p5, true, p6)
				&& all_right;
		// ------------------
	}

	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// END KAWIGIEDIT TESTING
